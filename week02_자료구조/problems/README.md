# [Silver IV] 큐 - 10845 

[문제 링크](https://www.acmicpc.net/problem/10845) 

## 📝 문제 설명
정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오. 큐(Queue)는 먼저 들어온 데이터가 먼저 나가는 **FIFO(First-In-First-Out)** 구조의 자료구조입니다.

---

## 📥 명령 종류 및 기능

| 명령 | 설명 |
| :--- | :--- |
| **`push X`** | 정수 $X$를 큐에 넣는 연산이다. |
| **`pop`** | 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. (비어있으면 `-1`) |
| **`size`** | 큐에 들어있는 정수의 개수를 출력한다. |
| **`empty`** | 큐가 비어있으면 `1`, 아니면 `0`을 출력한다. |
| **`front`** | 큐의 가장 앞에 있는 정수를 출력한다. (비어있으면 `-1`) |
| **`back`** | 큐의 가장 뒤에 있는 정수를 출력한다. (비어있으면 `-1`) |

---

## ⚙️ 입력 및 출력

### **입력**
- 첫째 줄에 주어지는 명령의 수 $N$ ($1 \le N \le 10,000$)이 주어집니다.
- 둘째 줄부터 $N$개의 줄에는 명령이 하나씩 주어집니다.
- 주어지는 정수는 $1 \le X \le 100,000$입니다.

### **출력**
- 출력해야 하는 명령이 주어질 때마다, 한 줄에 하나씩 결과를 출력합니다.

---

## 💡 풀이 전략
1. **데이터 구조**: 
   - `list`를 사용할 수 있으나, `pop(0)` 연산 시 시간 복잡도가 $O(N)$이 발생하므로 성능을 위해 `collections.deque`를 사용하는 것이 효율적입니다.
2. **조건 처리**:
   - `pop`, `front`, `back` 연산 시 큐가 비어있는 상태인지(`if not queue`) 먼저 확인하여 예외값 `-1`을 처리합니다.
3. **빠른 입출력**:
   - 명령의 수가 많으므로 `sys.stdin.readline`을 사용하여 입력 속도를 최적화합니다.
  


# [Silver II] 최대 힙 - 11279 

[문제 링크](https://www.acmicpc.net/problem/11279) 

## 📝 문제 설명
최대 힙(Max Heap)을 이용하여 다음 연산을 지원하는 프로그램을 작성하는 문제입니다.
1. 배열에 자연수 $x$를 넣는다.
2. 배열에서 가장 큰 값을 출력하고, 그 값을 배열에서 제거한다.
3. 빈 배열에서 시작하며, 비어 있는 상태에서 최댓값을 출력하라고 하면 `0`을 출력한다.

---

## 🌲 자료구조: 최대 힙 (Max Heap)
최대 힙은 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진트리 기반의 자료구조입니다.



- **삽입 연산**: 새로운 원소를 마지막 노드에 추가한 뒤, 부모와 비교하며 위로 올립니다 (Heapify-up).
- **삭제 연산**: 루트 노드(최댓값)를 제거하고, 마지막 노드를 루트로 옮긴 뒤 자식과 비교하며 아래로 내립니다 (Heapify-down).

---

## ⚙️ 입력 및 출력

### **입력**
- 첫째 줄에 연산의 개수 $N$ ($1 \le N \le 100,000$)이 주어집니다.
- 다음 $N$개의 줄에는 연산에 대한 정수 $x$가 주어집니다.
  - $x > 0$: 배열에 $x$를 추가합니다.
  - $x = 0$: 배열에서 가장 큰 값을 출력하고 제거합니다.

### **출력**
- $x=0$이 주어질 때마다 결과를 한 줄에 하나씩 출력합니다. (배열이 비어있으면 `0` 출력)

---

## 💡 풀이 전략
1. **힙 라이브러리 활용**: 
   - Python의 `heapq` 모듈은 기본적으로 **최소 힙(Min Heap)**으로 동작합니다.
   - **최대 힙**을 구현하기 위해 데이터 삽입 시 값을 **음수**로 바꾸어 넣고, 출력할 때 다시 부호를 바꾸는 방식을 사용합니다.
2. **시간 복잡도**:
   - 삽입/삭제 연산은 $O(\log N)$입니다. 
   - 총 $N$개의 연산을 처리하므로 전체 시간 복잡도는 $O(N \log N)$으로, 제한 시간 내에 충분히 해결 가능합니다.
3. **빠른 입출력**:
   - 연산 횟수가 많으므로 `sys.stdin.readline`을 사용하여 입출력 속도를 확보합니다.



이번에는 양방향에서 삽입과 삭제가 가능한 백준 10866번 '덱(Deque)' 문제입니다. 이전과 동일하게 바로 복사해서 사용하실 수 있는 마크다운 형식으로 정리해 드립니다.

Markdown
# [Silver IV] 덱 - 10866 

[문제 링크](https://www.acmicpc.net/problem/10866) 

## 📝 문제 설명
정수를 저장하는 **덱(Deque, Double-Ended Queue)**을 구현하고, 입력으로 주어지는 8가지 명령을 처리하는 프로그램을 작성하는 문제입니다. 덱은 양 끝에서 삽입과 삭제가 모두 가능한 유연한 자료구조입니다.

---

## 📥 명령 종류 및 기능

| 명령 | 설명 |
| :--- | :--- |
| **`push_front X`** | 정수 $X$를 덱의 앞에 넣는다. |
| **`push_back X`** | 정수 $X$를 덱의 뒤에 넣는다. |
| **`pop_front`** | 가장 앞에 있는 수를 빼고 출력 (비어있으면 `-1`) |
| **`pop_back`** | 가장 뒤에 있는 수를 빼고 출력 (비어있으면 `-1`) |
| **`size`** | 덱에 들어있는 정수의 개수 출력 |
| **`empty`** | 덱이 비어있으면 `1`, 아니면 `0` 출력 |
| **`front`** | 가장 앞에 있는 정수 출력 (비어있으면 `-1`) |
| **`back`** | 가장 뒤에 있는 정수 출력 (비어있으면 `-1`) |



---

## ⚙️ 입력 및 출력

### **입력**
- 첫째 줄에 주어지는 명령의 수 $N$ ($1 \le N \le 10,000$)이 주어집니다.
- 둘째 줄부터 $N$개의 줄에는 명령이 하나씩 주어집니다.
- 주어지는 정수 $X$는 $1 \le X \le 100,000$입니다.

### **출력**
- 명령이 주어질 때마다 결과를 한 줄에 하나씩 출력합니다.

---

## 💡 풀이 전략
1. **자료구조 선택**: 
   - Python의 `collections.deque`는 양 끝의 삽입/삭제가 모두 $O(1)$로 최적화되어 있어 이 문제에 가장 적합합니다.
   - 일반 `list`를 사용해 `insert(0, v)`나 `pop(0)`을 하면 $O(N)$의 시간이 걸려 비효율적입니다.
2. **조건 처리**:
   - `pop_front`, `pop_back`, `front`, `back` 연산 시 덱이 비어있는지(`if not deque`) 확인하여 `-1` 처리를 꼼꼼히 합니다.
3. **입력 최적화**:
   - `sys.stdin.readline`을 사용하여 대량의 입력 데이터를 빠르게 처리합니다.