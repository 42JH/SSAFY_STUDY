## 연습 문제
BFS: 백준 '미로 탐색(2178)'

다익스트라: 백준 '최단경로(1753)'

플로이드-워셜: 백준 '경로 찾기(11403)'

# 최단경로 study

### BFS (Breadth-First Search) 최단 거리

- **핵심 원리:** 현재 위치에서 가까운 곳부터 "층별로" 탐색
- **큐(Queue)**를 사용하여 방문 순서를 보장
- **주의점:** 가중치가 있는 그래프(예: 길마다 걸리는 시간이 다름)에서는 BFS로 최단거리를 구할 수 없다

### **다익스트라 (Dijkstra)**

• **핵심 원리:** "가장 비용이 적은 노드"를 먼저 선택해 나가는 그리디(Greedy) 방식
• 파이썬의 `heapq` 모듈을 사용한 **우선순위 큐** 구현 방식을 이용. 
• 주의점**:** 음의 가중치가 있을 때는 사용할 수 없다

### **플로이드-워셜 (Floyd-Warshall)**

• **핵심 원리:** "거쳐가는 노드"를 기준으로 테이블을 갱신하는 다이나믹 프로그래밍(DP) 방식입니다.
•`distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])`

### BFS (Breadth-First Search) 최단 거리

1. **시작점**을 큐에 넣고 '방문 표시'를 합니다.
2. 큐에서 하나를 꺼내 그 지점과 **연결된(인접한) 노드**들을 확인합니다.
3. 아직 방문하지 않은 노드가 있다면, **(현재 거리 + 1)**을 저장하고 큐에 넣습니다.
4. 큐가 빌 때까지 2~3번을 반복합니다.

> **왜 BFS가 최단거리인가**
BFS는 출발점에서 거리가 1인 곳을 다 찾고, 그다음 거리가 2인 곳을 다 찾는 식으로 확장한다. 따라서 어떤 목적지에 처음 도달하는 순간, 그 경로가 무조건 가장 짧은 경로임이 보장된다.
> 

```python
from collections import deque

def bfs(start_x, start_y):
    # 큐 구현을 위해 deque 라이브러리 사용
    queue = deque([(start_x, start_y)])
    
    # 큐가 빌 때까지 반복
    while queue:
        x, y = queue.popleft()
        
        # 현재 위치에서 4가지 방향(상, 하, 좌, 우) 확인
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            
            # 미로 범위를 벗어나면 무시
            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue
            # 벽(0)이면 무시
            if graph[nx][ny] == 0:
                continue
            
            # 해당 노드를 처음 방문하는 경우에만 최단 거리 기록
            if graph[nx][ny] == 1:
                graph[nx][ny] = graph[x][y] + 1
                queue.append((nx, ny))
    
    # 가장 오른쪽 아래(도착 지점)까지의 최단 거리 반환
    return graph[n-1][m-1]

# 이동할 네 가지 방향 정의 (상, 하, 좌, 우)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
```

길마다 통행료가 다를 경우는 다익스트라를 이용

### **다익스트라의 핵심 원리: "가장 싼 곳부터 가보자"**

- 다익스트라는 **그리디(Greedy, 탐욕법)** 알고리즘의 일종. 매 순간 '지금 당장 갈 수 있는 곳 중 가장 비용이 적은 노드'를 선택
1. **출발점**을 설정하고, 다른 모든 노드까지의 거리를 **무한대($\infty$)**로 초기화합니다.
2. 아직 방문하지 않은 노드 중에서 **거리가 가장 짧은 노드**를 선택합니다.
3. 그 노드를 거쳐서 인접한 다른 노드로 가는 비용을 계산해, 기존 비용보다 작으면 갱신
4. 모든 노드를 방문할 때까지 2~3번을 반복합니다.
- **우선순위 큐를 쓰는 이유**
그냥 리스트를 써서 "가장 짧은 노드"를 일일이 찾으면 시간이 너무 오래 걸림. 그래서 파이썬에서는 `heapq` 라이브러리를 사용해 **가장 작은 값을 알아서 맨 앞으로 보내주는** 우선순위 큐를 활용합니다. 이렇게 하면 훨씬 빨라짐
- 

그냥 리스트를 쓰는 경우 시간 복잡도: $O(V^2)$

우선순위 큐를 쓰는 경우 시간 복잡도:  $O(E log V)$

### 다익스트라의 한계

- **다익스트라는 음수 간선이 불가능**
- 한 지점에서 출발해 다른 모든 지점으로 가는 최단거리를 구하는 용도

```python
import heapq

def dijkstra(start):
    q = []
    # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여 큐에 삽입
    heapq.heappush(q, (0, start))
    distance[start] = 0
    
    while q:
        # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
        dist, now = heapq.heappop(q)
        
        # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
        if distance[now] < dist:
            continue
            
        # 현재 노드와 연결된 다른 인접한 노드들을 확인
        for i in graph[now]:
            cost = dist + i[1] # 현재까지 거리 + 연결된 간선 비용
            
            # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

# 데이터 초기화 예시 (무한대로 설정)
INF = int(1e9)
distance = [INF] * (n + 1)
```

### **플로이드-워셜의 핵심 원리: "거쳐가는 노드"**

이 알고리즘의 핵심 로직은 아주 단순합니다. “A에서 B로 바로 가는 것보다, 중간에 K를 거쳐서 가는 게 더 빠를까?”를 모든 노드에 대해 확인하는 것

1. **2차원 테이블**을 만듭니다. (행은 출발지, 열은 도착지)
2. 자기 자신으로 가는 거리는 0, 나머지는 무한대($\infty$)로 초기화한 뒤 연결된 길의 비용을 적습니다.
3. **1번 노드부터 N번 노드까지 하나씩 '거쳐가는 노드(K)'로 설정**하며 테이블을 갱신합니다.

![image.png](attachment:02cf9855-89e3-437d-9061-2328e9bc2ed4:image.png)

**다익스트라보다 느린 이유**

- 플로이드 - 워셜은 3중 for 문을 사용하기 때문에
    - 거쳐가는 노드 K
    - 출발 노드 A
    - 도착 노드 B
    

따라서 시간 복잡도가 $O(V^3)$이다.

만약 노드가 500개라면 $500 \times 500 \times 500 = 125,000,000$ (1억 2,500만) 번의 연산이 필요.

보통 알고리즘 문제에서 **노드 개수가 500개 이하**일 때만 이 알고리즘을 사용

```python
# 노드의 개수 n, 간선의 개수 m
INF = int(1e9)
graph = [[INF] * (n + 1) for _ in range(n + 1)]

# 자기 자신으로 가는 비용은 0으로 초기화
for a in range(1, n + 1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

# 각 간선 정보를 입력받아 테이블 초기화 (길이 있으면 그 값으로)
for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a][b] = c

# 점화식에 따라 플로이드 워셜 알고리즘 수행
for k in range(1, n + 1): # 거쳐가는 노드
    for a in range(1, n + 1): # 출발 노드
        for b in range(1, n + 1): # 도착 노드
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])
```

- 플로이드 워셜은 음수 간선 가능
- 구현이 편하다 (코드가 짧기 때문)
- 모든 경로 정보를 얻을 수 있음
    - 실행이 끝나면 2차원 리스트에 모든 노드 쌍 간의 최단 거리가 저장되어 있어서 여러번의 쿼리에 즉시 답할 수 있음