# [Silver I] 미로 탐색 - 2178 

[문제 링크](https://www.acmicpc.net/problem/2178) 

## 📝 문제 설명
$N \times M$ 크기의 배열로 표현되는 미로가 있습니다. 
- **1**: 이동할 수 있는 칸
- **0**: 이동할 수 없는 칸

$(1, 1)$에서 출발하여 $(N, M)$의 위치로 이동할 때 지나야 하는 **최소의 칸 수**를 구하는 프로그램을 작성하시오. 칸을 셀 때에는 시작 위치와 도착 위치도 포함합니다.

---

## 🔍 알고리즘: 너비 우선 탐색 (BFS)
이 문제는 가중치가 없는 그래프에서 **최단 거리**를 찾는 문제이므로 **BFS(Breadth-First Search)**를 사용하는 것이 가장 효율적입니다.



### **BFS를 사용하는 이유**
- DFS(깊이 우선 탐색)는 모든 경로를 탐색하거나 한 경로를 끝까지 파고들기 때문에 최단 경로를 보장하기 위해 추가적인 처리가 필요합니다.
- 반면 **BFS**는 현재 위치에서 가까운 곳부터 차례대로 탐색하므로, **처음으로 도착점에 도달했을 때의 거리가 곧 최단 거리**가 됩니다.

---

## ⚙️ 입력 및 출력

### **입력**
- 첫째 줄에 두 정수 $N, M$ ($2 \le N, M \le 100$)이 주어집니다.
- 다음 $N$개의 줄에는 $M$개의 정수가 **공백 없이** 붙어서 주어집니다.

### **출력**
- 첫째 줄에 $(1, 1)$에서 $(N, M)$까지 가는 최소 칸 수를 출력합니다.

---

## 💡 풀이 전략
1. **방향 벡터 설정**:
   - 한 칸에서 상, 하, 좌, 우로 인접한 칸을 체크하기 위해 `dx = [-1, 1, 0, 0]`, `dy = [0, 0, -1, 1]`와 같은 방향 배열을 사용합니다.
2. **거리 기록**:
   - 별도의 방문 확인 배열(`visited`)을 만들거나, 기존 미로 배열에 출발점으로부터의 거리를 누적하여 기록합니다.
   - 예: `maze[nx][ny] = maze[x][y] + 1`
3. **큐(Queue) 활용**:
   - 탐색할 좌표를 `deque`에 넣고, 방문하지 않은 인접한 '1'인 칸을 찾을 때마다 큐에 삽입합니다.
4. **결과 도출**:
   - 큐가 빌 때까지 반복하거나 $(N, M)$ 좌표에 도달했을 때의 누적 값을 출력합니다.

---

## ⚠️ 주의 사항
- **좌표 보정**: 문제에서는 $(1, 1)$부터 시작한다고 되어 있지만, 대부분의 프로그래밍 언어에서 배열 인덱스는 `(0, 0)`부터 시작하므로 인덱스 처리에 유의해야 합니다.
- **입력 처리**: 숫자가 붙어서 입력되므로 문자열로 받아 한 글자씩 나누어 정수로 변환해야 합니다.



##########################################################
# [Gold IV] 최단경로 - 1753 

[문제 링크](https://www.acmicpc.net/problem/1753) 

## 📝 문제 설명
방향 그래프가 주어졌을 때, 주어진 시작점에서 다른 모든 정점으로의 **최단 경로**를 구하는 프로그램을 작성하시오. 모든 간선의 가중치는 10 이하의 자연수입니다.

---

## 🔍 알고리즘: 다익스트라 (Dijkstra)
이 문제는 음의 가중치가 없는 그래프에서 한 지점으로부터 다른 모든 지점까지의 최단 거리를 구하는 **다익스트라(Dijkstra) 알고리즘**을 사용하여 해결할 수 있습니다.

[Image of Dijkstra's algorithm step-by-step visualization on a weighted graph]

### **다익스트라 알고리즘의 핵심**
1. **거리 배열 초기화**: 시작점은 `0`, 나머지 모든 정점은 무한대(`INF`)로 설정합니다.
2. **우선순위 큐(Priority Queue) 사용**: 거리가 가장 짧은 노드를 우선적으로 선택하여 탐색하기 위해 최소 힙(Min Heap)을 활용합니다.
3. **최단 거리 갱신(Relaxation)**: 현재 노드를 거쳐서 인접 노드로 이동하는 거리가 기존에 기록된 거리보다 짧다면 정보를 업데이트합니다.
   - $dist[v] = \min(dist[v], dist[u] + w)$

---

## ⚙️ 입력 및 출력

### **입력**
- 첫째 줄: 정점의 개수 $V$ ($1 \le V \le 20,000$), 간선의 개수 $E$ ($1 \le E \le 300,000$)
- 둘째 줄: 시작 정점의 번호 $K$
- 셋째 줄부터 $E$개의 줄: 간선을 나타내는 세 정수 $(u, v, w)$ (시작, 끝, 가중치)

### **출력**
- $V$개의 줄에 걸쳐 $i$번째 정점으로의 최단 경로 값을 출력합니다.
- 시작점은 `0`, 경로가 없는 경우 `INF`를 출력합니다.

---

## 💡 풀이 전략
1. **인접 리스트 구성**:
   - 정점의 개수가 최대 20,000개이므로 인접 행렬($V^2$)보다는 **인접 리스트**를 사용하여 메모리 효율을 높입니다.
   - 같은 정점 사이에 여러 간선이 존재할 수 있으므로 모두 리스트에 담아 처리합니다.
2. **우선순위 큐 활용**:
   - 단순히 최단 거리를 찾는 방식($O(V^2)$)은 시간 초과가 날 수 있습니다. 우선순위 큐를 사용하면 $O(E \log V)$의 시간 복잡도로 해결이 가능합니다.
3. **무한대(INF) 설정**:
   - 가중치 합의 최댓값을 고려하여 충분히 큰 값(예: `int(1e9)`)으로 초기화합니다.

---

## ⚠️ 주의 사항
- **메모리 제한**: $V$와 $E$의 범위가 크기 때문에 불필요한 객체 생성을 줄이고 효율적인 자료구조를 사용해야 합니다.
- **입력 속도**: $E$가 300,000에 달하므로 빠른 입출력 함수(`sys.stdin.readline` 등) 사용이 필수적입니다.




###############################################################
# [Gold IV] 플로이드 - 11404 

[문제 링크](https://www.acmicpc.net/problem/11404) 

## 📝 문제 설명
$n$개의 도시와 도시를 잇는 $m$개의 버스 노선이 주어질 때, **모든 도시의 쌍 (A, B)에 대해** A에서 B로 가는 최소 비용을 구하는 문제입니다. 모든 정점에서 다른 모든 정점으로의 최단 거리를 구해야 합니다.

---

## 🔍 알고리즘: 플로이드-워셜 (Floyd-Warshall)
이 문제는 모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 **플로이드-워셜(Floyd-Warshall) 알고리즘**의 가장 기본적인 문제입니다.



### **알고리즘의 핵심 원리**
1. **2차원 인접 행렬**: 모든 도시 쌍의 거리를 저장할 $n \times n$ 크기의 테이블을 만듭니다.
2. **3중 반복문**: '거쳐가는 도시'를 가장 바깥쪽 반복문에 둡니다.
   - $k$: 거쳐가는 노드
   - $i$: 출발 노드
   - $j$: 도착 노드
3. **점화식**: $i$에서 $j$로 바로 가는 것보다 $k$를 거쳐서 가는 것이 더 빠르다면 거리를 갱신합니다.
   $$dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])$$

---

## ⚙️ 입력 및 출력

### **입력**
- 첫째 줄: 도시의 개수 $n$ ($2 \le n \le 100$)
- 둘째 줄: 버스의 개수 $m$ ($1 \le m \le 100,000$)
- 셋째 줄부터 $m$개의 줄: 버스의 정보 $a$(출발), $b$(도착), $c$(비용)

### **출력**
- $n$개의 줄에 걸쳐 각 도시 i에서 j로 가는 최소 비용을 행렬 형태로 출력합니다.
- 갈 수 없는 경우 `0`을 출력합니다.

---

## 💡 풀이 전략
1. **초기화**:
   - 자기 자신으로 가는 거리($i=j$)는 `0`으로 설정합니다.
   - 나머지는 아주 큰 값(`INF`)으로 초기화합니다.
2. **중복 노선 처리**:
   - 시작 도시와 도착 도시가 같은 노선이 여러 개 있을 수 있습니다. 입력을 받을 때 그중 **가장 작은 비용**만 저장해야 합니다.
   - `dist[a][b] = min(dist[a][b], cost)`
3. **결과 처리**:
   - 모든 계산이 끝난 후 여전히 값이 `INF`라면, 해당 경로는 갈 수 없는 곳이므로 문제 조건에 따라 `0`으로 바꾸어 출력합니다.

---

## ⚠️ 주의 사항
- **시간 복잡도**: 플로이드-워셜의 시간 복잡도는 $O(n^3)$입니다. 이 문제에서 $n$이 최대 100이므로 $100^3 = 1,000,000$ 연산이 필요하며, 이는 제한 시간 내에 충분히 수행 가능합니다.
- **가중치**: 가중치가 100,000 이하의 자연수이므로 다익스트라보다 구현이 훨씬 간단한 플로이드-워셜이 유리합니다.