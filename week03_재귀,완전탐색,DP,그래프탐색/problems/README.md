# 🚀 02_15 알고리즘 문제

**재귀, 완전탐색, 그래프 탐색(DFS/BFS), 그리고 DP**를 복합적으로 연습할 수 있는 정석 문제입니다.

---

### 1. [DFS/BFS] [1226. 미로 1 (D4)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV14vXUqAGMCFAYD)
**[문제 내용]**
16x16 크기의 미로에서 출발점(2)에서 도착점(3)까지 갈 수 있는 길이 있는지 판단하는 프로그램을 작성하십시오. 
- `0`: 길 (이동 가능)
- `1`: 벽 (이동 불가능)
- `2`: 출발점
- `3`: 도착점

**[입력/출력]**
- 총 10개의 테스트 케이스가 주어집니다.
- 도착 가능하면 `1`, 불가능하면 `0`을 출력합니다.

**[핵심 전략]**
- **탐색 방식**: DFS(스택/재귀) 또는 BFS(큐)를 사용합니다.
- **방향 벡터**: `dx = [-1, 1, 0, 0]`, `dy = [0, 0, -1, 1]`을 사용하여 상하좌우를 탐색합니다.
- **방문 체크**: 이미 방문한 길을 다시 방문하지 않도록 `visited` 배열을 관리하는 것이 핵심입니다.

---

### 2. [완전탐색/백트래킹] [1244. 최대 상금 (D3)]https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15Khn6AN0CFAYD)
**[문제 내용]**
숫자판이 주어지고, 정해진 횟수(K)만큼 두 숫자의 위치를 교환해야 합니다. 정해진 횟수를 **반드시 모두 사용**했을 때 얻을 수 있는 수 중 가장 큰 값을 구하십시오.
- 동일한 위치의 숫자를 여러 번 교환할 수 있습니다.
- 숫자판은 최대 6자리, 교환 횟수는 최대 10번입니다.

**[핵심 전략]**
- **함정**: 매 순간 큰 수를 앞으로 보내는 '그리디' 방식은 최적해를 보장하지 않습니다. (예: 32888 같은 경우)
- **해결**: 가능한 모든 교환을 시도하는 **DFS(백트래킹)**가 필요합니다.
- **최적화**: 동일한 횟수차에서 동일한 숫자판 상태가 나타나면 더 이상 탐색하지 않는 **중복 제거(Set 활용 또는 메모이제이션)**가 필수입니다.

---

### 3. [동적 계획법] [3307. 최장 증가 부분 수열 (D3)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWBOKg-a6l0DFAWr)
**[문제 내용]**
주어진 수열에서 순서를 유지하면서 크기가 점점 커지는 부분 수열 중 가장 긴 길이를 계산하십시오.
- 예: `{1, 3, 2, 5, 4, 7}` → LIS는 `{1, 2, 4, 7}`로 길이는 `4`입니다.

**[핵심 전략]**
- **DP 상태 정의**: `dp[i]`를 "i번째 원소를 **마지막 원소**로 하는 최장 증가 부분 수열의 길이"로 정의합니다.
- **점화식**: `dp[i] = max(dp[j]) + 1` (단, `j < i` 이고 `A[j] < A[i]`인 경우)
- **시간 복잡도**: $O(N^2)$로 해결 가능하며, $N$이 매우 클 경우 이분 탐색($O(N \log N)$)을 고려할 수 있습니다.

---
**💡 Study Tip**: 각 문제를 풀 때 앞선 발표에서 정리한 **[실전 문제] 템플릿**을 참고하여 구현해 보세요
